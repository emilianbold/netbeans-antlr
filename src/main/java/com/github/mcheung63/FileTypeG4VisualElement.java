package com.github.mcheung63;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.nio.charset.Charset;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import javax.print.PrintException;
import javax.swing.Action;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.JPanel;
import javax.swing.JToolBar;
import static org.antlr.v4.gui.TestRig.LEXER_START_RULE_NAME;
import org.antlr.v4.gui.Trees;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonToken;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.DiagnosticErrorListener;
import org.antlr.v4.runtime.Lexer;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenStream;
import org.antlr.v4.runtime.atn.PredictionMode;
import org.apache.commons.io.FileUtils;
import org.netbeans.core.spi.multiview.CloseOperationState;
import org.netbeans.core.spi.multiview.MultiViewElement;
import org.netbeans.core.spi.multiview.MultiViewElementCallback;
import org.openide.awt.UndoRedo;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;

@MultiViewElement.Registration(
		displayName = "#LBL_FileTypeG4_VISUAL",
		iconBase = "com/github/mcheung63/antlr.png",
		mimeType = "text/x-g4",
		persistenceType = TopComponent.PERSISTENCE_NEVER,
		preferredID = "FileTypeG4Visual",
		position = 2000
)
@Messages("LBL_FileTypeG4_VISUAL=Visual")
public final class FileTypeG4VisualElement extends JPanel implements MultiViewElement {

	private FileTypeG4DataObject obj;
	private JToolBar toolbar = new JToolBar();
	private transient MultiViewElementCallback callback;
	String startRuleName;
	String grammarName;
	boolean showTokens = true;
	boolean diagnostics = true;
	boolean gui = true;
	boolean SLL = true;
	boolean trace = true;
	boolean printTree = true;
	String psFile = null;

	public FileTypeG4VisualElement(Lookup lkp) {
		obj = lkp.lookup(FileTypeG4DataObject.class);
		assert obj != null;
		initComponents();
	}

	@Override
	public String getName() {
		return "FileTypeG4VisualElement";
	}

	/**
	 * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
	 */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane1 = new javax.swing.JTabbedPane();
        treePanel = new javax.swing.JPanel();
        refreshTreeButton = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        contentTextArea = new javax.swing.JTextArea();
        browseTestFileButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        startRuleTextField = new javax.swing.JTextField();

        setLayout(new java.awt.BorderLayout());

        refreshTreeButton.setLabel(org.openide.util.NbBundle.getMessage(FileTypeG4VisualElement.class, "FileTypeG4VisualElement.refreshTreeButton.label")); // NOI18N
        refreshTreeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                refreshTreeButtonActionPerformed(evt);
            }
        });

        contentTextArea.setColumns(20);
        contentTextArea.setRows(5);
        contentTextArea.setText(org.openide.util.NbBundle.getMessage(FileTypeG4VisualElement.class, "FileTypeG4VisualElement.contentTextArea.text")); // NOI18N
        jScrollPane1.setViewportView(contentTextArea);

        org.openide.awt.Mnemonics.setLocalizedText(browseTestFileButton, org.openide.util.NbBundle.getMessage(FileTypeG4VisualElement.class, "FileTypeG4VisualElement.browseTestFileButton.text")); // NOI18N
        browseTestFileButton.setToolTipText(org.openide.util.NbBundle.getMessage(FileTypeG4VisualElement.class, "FileTypeG4VisualElement.browseTestFileButton.toolTipText")); // NOI18N
        browseTestFileButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                browseTestFileButtonActionPerformed(evt);
            }
        });

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, org.openide.util.NbBundle.getMessage(FileTypeG4VisualElement.class, "FileTypeG4VisualElement.jLabel1.text")); // NOI18N

        startRuleTextField.setText(org.openide.util.NbBundle.getMessage(FileTypeG4VisualElement.class, "FileTypeG4VisualElement.startRuleTextField.text")); // NOI18N

        javax.swing.GroupLayout treePanelLayout = new javax.swing.GroupLayout(treePanel);
        treePanel.setLayout(treePanelLayout);
        treePanelLayout.setHorizontalGroup(
            treePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(treePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(treePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1)
                    .addGroup(treePanelLayout.createSequentialGroup()
                        .addComponent(browseTestFileButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(refreshTreeButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(startRuleTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 347, Short.MAX_VALUE)))
                .addContainerGap())
        );
        treePanelLayout.setVerticalGroup(
            treePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(treePanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(treePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(refreshTreeButton)
                    .addComponent(browseTestFileButton)
                    .addComponent(jLabel1)
                    .addComponent(startRuleTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 667, Short.MAX_VALUE)
                .addContainerGap())
        );

        jTabbedPane1.addTab(org.openide.util.NbBundle.getMessage(FileTypeG4VisualElement.class, "FileTypeG4VisualElement.treePanel.TabConstraints.tabTitle"), treePanel); // NOI18N

        add(jTabbedPane1, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    private void refreshTreeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_refreshTreeButtonActionPerformed
		/*String base = "/Users/peter/Desktop";
		new File(base + "/temp").delete();
		new File(base + "/temp").mkdir();
		File file = new File(obj.getPrimaryFile().getPath());
		try {
			Files.copy(file.toPath(), new File(base + "/temp/" + file.getName()).toPath());
		} catch (IOException ex) {
			ModuleLib.log("exception=" + ModuleLib.printException(ex));
		}
		try {
			File f = new File(base + "/temp/" + file.getName());
			GenericParser gp = new GenericParser(f);
			String s = FileUtils.loadFileContent("HelloWorld.java");

			DefaultTreeListener dlist = new DefaultTreeListener();

			gp.setListener(dlist);
			gp.compile();

			ParserRuleContext ctx = gp.parse(s);

			Ast ast = dlist.getAst();
			ModuleLib.log(ast.toDot());
		} catch (Exception ex) {
			ModuleLib.log("exception=" + ModuleLib.printException(ex));
		}*/

//		try {
//			File file = new File(obj.getPrimaryFile().getPath());
//			ModuleLib.log(file.getAbsolutePath());
////			System.out.println(Paths.get(getClass().getResource("Calculator.g4").toURI()));
////			String content = new String(Files.readAllBytes(Paths.get(getClass().getResource("Calculator.g4").toURI())));
//			GenericParser gp = new GenericParser(file);
//			DefaultTreeListener treeListener = new DefaultTreeListener();
//			gp.setListener(treeListener);
//			gp.compile();
//			ParserRuleContext ctx = gp.parse(contentTextArea.getText());
//			Ast ast = treeListener.getAst();
//			List<AstNode> nodes = ast.getNodes();
//			for (AstNode n : nodes) {
//				ModuleLib.log(n);
//				//loop("", n);
//			}
//			System.out.println(ast.toDot());
//		} catch (Exception ex) {
//			ModuleLib.log(ex.getMessage());
//		}
		try {
			File file = new File(obj.getPrimaryFile().getPath());
			startRuleName = startRuleTextField.getText();
			grammarName = file.getName();
			String lexerName = grammarName + "Lexer";
			ClassLoader cl = Thread.currentThread().getContextClassLoader();
			Class<? extends Lexer> lexerClass = null;
			try {
				lexerClass = cl.loadClass(lexerName).asSubclass(Lexer.class);
			} catch (java.lang.ClassNotFoundException cnfe) {
				// might be pure lexer grammar; no Lexer suffix then
				lexerName = grammarName;
				try {
					lexerClass = cl.loadClass(lexerName).asSubclass(Lexer.class);
				} catch (ClassNotFoundException cnfe2) {
					ModuleLib.log("Can't load " + lexerName + " as lexer or parser");
					return;
				}
			}

			Constructor<? extends Lexer> lexerCtor = lexerClass.getConstructor(CharStream.class);
			Lexer lexer = lexerCtor.newInstance((CharStream) null);

			Class<? extends Parser> parserClass = null;
			Parser parser = null;
			if (!startRuleName.equals(LEXER_START_RULE_NAME)) {
				String parserName = grammarName + "Parser";
				parserClass = cl.loadClass(parserName).asSubclass(Parser.class);
				Constructor<? extends Parser> parserCtor = parserClass.getConstructor(TokenStream.class);
				parser = parserCtor.newInstance((TokenStream) null);
			}

			String encoding = "UTF-8";
			Charset charset = (encoding == null ? Charset.defaultCharset() : Charset.forName(encoding));
			List<String> inputFiles = new ArrayList<String>();
			if (inputFiles.size() == 0) {
				CharStream charStream = CharStreams.fromStream(System.in, charset);
				process(lexer, parserClass, parser, charStream);
				return;
			}
			for (String inputFile : inputFiles) {
				CharStream charStream = CharStreams.fromPath(Paths.get(inputFile), charset);
				if (inputFiles.size() > 1) {
					System.err.println(inputFile);
				}
				process(lexer, parserClass, parser, charStream);
			}
		} catch (Exception ex) {
			ModuleLib.log(ex.getMessage());
		}
    }//GEN-LAST:event_refreshTreeButtonActionPerformed

	void process(Lexer lexer, Class<? extends Parser> parserClass, Parser parser, CharStream input) throws IOException, IllegalAccessException, InvocationTargetException, PrintException {
		lexer.setInputStream(input);
		CommonTokenStream tokens = new CommonTokenStream(lexer);

		tokens.fill();

		if (showTokens) {
			for (Token tok : tokens.getTokens()) {
				if (tok instanceof CommonToken) {
					System.out.println(((CommonToken) tok).toString(lexer));
				} else {
					System.out.println(tok.toString());
				}
			}
		}

		if (startRuleName.equals(LEXER_START_RULE_NAME)) {
			return;
		}

		if (diagnostics) {
			parser.addErrorListener(new DiagnosticErrorListener());
			parser.getInterpreter().setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);
		}

		//if (printTree || gui || psFile != null) {
		if (gui) {
			parser.setBuildParseTree(true);
		}

		if (SLL) { // overrides diagnostics
			parser.getInterpreter().setPredictionMode(PredictionMode.SLL);
		}

		parser.setTokenStream(tokens);
		parser.setTrace(trace);

		try {
			Method startRule = parserClass.getMethod(startRuleName);
			ParserRuleContext tree = (ParserRuleContext) startRule.invoke(parser, (Object[]) null);

			if (printTree) {
				System.out.println(tree.toStringTree(parser));
			}
			if (gui) {
				Trees.inspect(tree, parser);
			}
			if (psFile != null) {
				Trees.save(tree, parser, psFile); // Generate postscript
			}
		} catch (NoSuchMethodException nsme) {
			System.err.println("No method for rule " + startRuleName + " or it has arguments");
		}
	}
    private void browseTestFileButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_browseTestFileButtonActionPerformed
		final JFileChooser fc = new JFileChooser();
		int returnVal = fc.showOpenDialog(null);

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			try {
				contentTextArea.setText(FileUtils.readFileToString(file, "UTF-8"));
			} catch (IOException ex) {
				Exceptions.printStackTrace(ex);
			}
			refreshTreeButtonActionPerformed(null);
		}
    }//GEN-LAST:event_browseTestFileButtonActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton browseTestFileButton;
    private javax.swing.JTextArea contentTextArea;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JButton refreshTreeButton;
    private javax.swing.JTextField startRuleTextField;
    private javax.swing.JPanel treePanel;
    // End of variables declaration//GEN-END:variables

	@Override
	public JComponent getVisualRepresentation() {
		return this;
	}

	@Override
	public JComponent getToolbarRepresentation() {
		return toolbar;
	}

	@Override
	public Action[] getActions() {
		return new Action[0];
	}

	@Override
	public Lookup getLookup() {
		return obj.getLookup();
	}

	@Override
	public void componentOpened() {
	}

	@Override
	public void componentClosed() {
	}

	@Override
	public void componentShowing() {
	}

	@Override
	public void componentHidden() {
	}

	@Override
	public void componentActivated() {
	}

	@Override
	public void componentDeactivated() {
	}

	@Override
	public UndoRedo getUndoRedo() {
		return UndoRedo.NONE;
	}

	@Override
	public void setMultiViewCallback(MultiViewElementCallback callback) {
		this.callback = callback;
	}

	@Override
	public CloseOperationState canCloseElement() {
		return CloseOperationState.STATE_OK;
	}

}
